# 의존성 주입

> 메인 모듈이 '직접' 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자가 이 부분을 가로채 메인 모듈이 '간접'적으로 의존성을 주입하는 방식이다. 이를 통해 메인 모듈과 하위 모듈간의 의존성을 조금 더 느슨하게 만들 수 있다. 그래서 모듈을 쉽게 교체 가능한 구조로 만든다.

### '의존한다'라는 것은 뭘까

> A가 B에 의존한다 (A -> B) = B가 변하면 A에 영향을 미친다. B코드가 변하면 A도 그에 맞춰 바꿔야 한다.

Project -> Module A
Project -> Module B

#### DI를 적용한다면 이렇게 변한다

> 쉽게 말하면, A와 B 모듈을 묶어 추상화한 DI 모듈에 의존하도록 바꾼다. 그리고 프로젝트는 DI 모듈만 바라보고 있기만 하면 된다.
> 이렇게 되면, A와 B 코드가 바뀌면 DI 모듈만 바꾸면 된다. 프로젝트 코드는 아예 건들지 않아도 된다.

Module A -> DI Module
Module B -> DI Module

Project -> DI Module

이런 것을 우리는 의존적인 화살표가 "역전"됐다고 한다.
이를 "의존관계역전원칙"이 적용됐다고 한다.

#### 의존관계역전원칙

> 의존성 주입을 할 때는 이가 적용된다.

아래 2가지 규칙을 지키는 상태다.

1. 상위 모듈은 하위 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다.
2. 추상화는 세부사항에 의존해서는 안 된다. 세부 사항은 추상화에 따라 달라져야 한다.

#### 장점

1. 외부에서 모듈을 생성해 집어넣는 구조가 되기에 모듈을 쉽게 교체할 수 있다.
2. 단위 테스팅과 마이그레이션이 쉬워진다.
3. 애플리케이션 의존성 방향이 좀 더 일관되어 코드를 추론하기 쉬워진다.

#### 단점

1. 결국 모듈이 더 생기게 되므로 복잡도가 증가한다.(하위모듈이 바뀌면, DI 모듈을 결국 바뀌어야 한다. + 결국 코드가 증가한다.)
2. 종속성 주입자체가 컴파일 할 때가 아닌, 런타임 때 일어난다. 그래서 컴파일을 할 때, 종속성 주입에 관한 에러를 잡기 어려워질 수 있다.
